ActivitySelection
	1) Greedy - sort by end time, then select first based on the current time.
	2) Either recursive or a loop.

AddTowNumbers
	1) just travese both linked list. caculate digit sum and carry. 
	2) need to deal with case that two list are not same in length
	3) be sure to continue look even if both pointers are null but carry is 1

AlternateArrayItems
	1) Use extra arrays;
	2) Swap inner half, then recursive all each half. Special handling for odd numbers (2n, whwre n is odd)

AlternateLists
	1) recursive;
	2) non recursive - be careful the case when list1 hit end but list2 is still valid

ArrayIsSubSequenceOfAnother:
	1) Hasing 
	2) use BinarySearch if not allowed for extra space 
BinarySearch
	1) Trivial

BinarySearchTree:
	1) Check valid BSF: a) use min-max range check recurisively; b) In-order traverse, previous must be less than current

BirdAndMaxFruitGathering
	1) most efficient solution just use the "moving window" on the original array. Use modulo operator for "over flow" items scenario

BottomViewOfBinaryTree
	1) better use BFS, queued items carry Node and its distance to root. With BFS there is no need to track depth.

BuildFromSortedArray:
	1) Start from mid, then recurisvely build left and right

BuildTreeFromInOrderAndPreOrderTraverse
	1) use List is a lot simpler

PathSum1
	1) recursive...

PathSum2
	2) recusive, each time returns a stack instead of a boolean. In case it asks for all the paths, return a list of stacks and don't stop right side call if left side returns.
ReverseInteger
	1) can use a stack to store reversed digits; can without stack, code is a little tricky
	3) need to deal with overflow

ParenthesisChecker
	1) Stack, of course
NextLargerElement
	1) O(N square) is simple;
	2) So called O(N), use a stack to store items (value and index) of desending sequence, once it
	   hits a greater one, all smaller items are poped, their coresponding location in result array
	   are updated with the greater value. 
EquilibriumPoint
	1) sum up from both directions, increase smaller, until left index greater than right. if both sums are same and l == h, return l.