ActivitySelection
	1) Greedy - sort by end time, then select first based on the current time.
	2) Either recursive or a loop.

AddTowNumbers
	1) just travese both linked list. caculate digit sum and carry. 
	2) need to deal with case that two list are not same in length
	3) be sure to continue look even if both pointers are null but carry is 1

AlternateArrayItems
	1) Use extra arrays;
	2) Swap inner half, then recursive all each half. Special handling for odd numbers (2n, whwre n is odd)

AlternateLists
	1) recursive;
	2) non recursive - be careful the case when list1 hit end but list2 is still valid

ArrayIsSubSequenceOfAnother:
	1) Hasing 
	2) use BinarySearch if not allowed for extra space 
BinarySearch
	1) Trivial

BinarySearchTree:
	1) Check valid BSF: a) use min-max range check recurisively; b) In-order traverse, previous must be less than current

BirdAndMaxFruitGathering
	1) most efficient solution just use the "moving window" on the original array. Use modulo operator for "over flow" items scenario

BottomViewOfBinaryTree
	1) better use BFS, queued items carry Node and its distance to root. With BFS there is no need to track depth.

BuildFromSortedArray:
	1) Start from mid, then recurisvely build left and right

BuildTreeFromInOrderAndPreOrderTraverse
	1) use List is a lot simpler

PathSum1
	1) recursive...

PathSum2
	2) recusive, each time returns a stack instead of a boolean. In case it asks for all the paths, return a list of stacks and don't stop right side call if left side returns.
ReverseInteger
	1) can use a stack to store reversed digits; can without stack, code is a little tricky
	3) need to deal with overflow

ParenthesisChecker
	1) Stack, of course
NextLargerElement
	1) O(N square) is simple;
	2) So called O(N), use a stack to store items (value and index) of desending sequence, once it
	   hits a greater one, all smaller items are poped, their coresponding location in result array
	   are updated with the greater value. 
EquilibriumPoint
	1) sum up from both directions, increase smaller, until left index greater than right. if both sums are same and l == h, return l.

SolveSudoku
	1) No need to start loops for solving, only need loops to find next 0 in the matrix - if not found, it's solved.

SubArrayWithGivenSum
	1) build up a dictionary with the "current sum" as key, then iterate through the arry, accumulate a sum,
	  and look up "currentSum + targetSum" in the dictionary
	2) be careful with the starting index.

SwappingPairMakeSumEqual:
	1) there should be no solution if the sum difference is an odd number;
	2) one solution is to sort both array, and start moving two points from left to right for matching.
TwoSum:
	1) can either build a map then iterate through to find match, or iterate and build map in same look, the later should be better.
WordBreak
	1) dynamic programming, but memo not useful
ZigZagConversion:
	1) Can use a data structure to form the shape
	2) Can do directly based on index, special logic for the middle row when the level is an even number